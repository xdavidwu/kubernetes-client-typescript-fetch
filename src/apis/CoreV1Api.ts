/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.30.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthenticationV1TokenRequest,
  CoreV1Event,
  CoreV1EventList,
  V1APIResourceList,
  V1Binding,
  V1ComponentStatus,
  V1ComponentStatusList,
  V1ConfigMap,
  V1ConfigMapList,
  V1DeleteOptions,
  V1Endpoints,
  V1EndpointsList,
  V1Eviction,
  V1LimitRange,
  V1LimitRangeList,
  V1Namespace,
  V1NamespaceList,
  V1Node,
  V1NodeList,
  V1PersistentVolume,
  V1PersistentVolumeClaim,
  V1PersistentVolumeClaimList,
  V1PersistentVolumeList,
  V1Pod,
  V1PodList,
  V1PodTemplate,
  V1PodTemplateList,
  V1ReplicationController,
  V1ReplicationControllerList,
  V1ResourceQuota,
  V1ResourceQuotaList,
  V1Scale,
  V1Secret,
  V1SecretList,
  V1Service,
  V1ServiceAccount,
  V1ServiceAccountList,
  V1ServiceList,
  V1Status,
} from '../models/index';
import {
    AuthenticationV1TokenRequestFromJSON,
    AuthenticationV1TokenRequestToJSON,
    CoreV1EventFromJSON,
    CoreV1EventToJSON,
    CoreV1EventListFromJSON,
    CoreV1EventListToJSON,
    V1APIResourceListFromJSON,
    V1APIResourceListToJSON,
    V1BindingFromJSON,
    V1BindingToJSON,
    V1ComponentStatusFromJSON,
    V1ComponentStatusToJSON,
    V1ComponentStatusListFromJSON,
    V1ComponentStatusListToJSON,
    V1ConfigMapFromJSON,
    V1ConfigMapToJSON,
    V1ConfigMapListFromJSON,
    V1ConfigMapListToJSON,
    V1DeleteOptionsFromJSON,
    V1DeleteOptionsToJSON,
    V1EndpointsFromJSON,
    V1EndpointsToJSON,
    V1EndpointsListFromJSON,
    V1EndpointsListToJSON,
    V1EvictionFromJSON,
    V1EvictionToJSON,
    V1LimitRangeFromJSON,
    V1LimitRangeToJSON,
    V1LimitRangeListFromJSON,
    V1LimitRangeListToJSON,
    V1NamespaceFromJSON,
    V1NamespaceToJSON,
    V1NamespaceListFromJSON,
    V1NamespaceListToJSON,
    V1NodeFromJSON,
    V1NodeToJSON,
    V1NodeListFromJSON,
    V1NodeListToJSON,
    V1PersistentVolumeFromJSON,
    V1PersistentVolumeToJSON,
    V1PersistentVolumeClaimFromJSON,
    V1PersistentVolumeClaimToJSON,
    V1PersistentVolumeClaimListFromJSON,
    V1PersistentVolumeClaimListToJSON,
    V1PersistentVolumeListFromJSON,
    V1PersistentVolumeListToJSON,
    V1PodFromJSON,
    V1PodToJSON,
    V1PodListFromJSON,
    V1PodListToJSON,
    V1PodTemplateFromJSON,
    V1PodTemplateToJSON,
    V1PodTemplateListFromJSON,
    V1PodTemplateListToJSON,
    V1ReplicationControllerFromJSON,
    V1ReplicationControllerToJSON,
    V1ReplicationControllerListFromJSON,
    V1ReplicationControllerListToJSON,
    V1ResourceQuotaFromJSON,
    V1ResourceQuotaToJSON,
    V1ResourceQuotaListFromJSON,
    V1ResourceQuotaListToJSON,
    V1ScaleFromJSON,
    V1ScaleToJSON,
    V1SecretFromJSON,
    V1SecretToJSON,
    V1SecretListFromJSON,
    V1SecretListToJSON,
    V1ServiceFromJSON,
    V1ServiceToJSON,
    V1ServiceAccountFromJSON,
    V1ServiceAccountToJSON,
    V1ServiceAccountListFromJSON,
    V1ServiceAccountListToJSON,
    V1ServiceListFromJSON,
    V1ServiceListToJSON,
    V1StatusFromJSON,
    V1StatusToJSON,
} from '../models/index';

export interface CoreV1ApiConnectDeleteNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectDeleteNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectDeleteNodeProxyRequest {
    name: string;
    path?: string;
}

export interface CoreV1ApiConnectDeleteNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectGetNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface CoreV1ApiConnectGetNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface CoreV1ApiConnectGetNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface CoreV1ApiConnectGetNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectGetNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectGetNodeProxyRequest {
    name: string;
    path?: string;
}

export interface CoreV1ApiConnectGetNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectHeadNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectHeadNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectHeadNodeProxyRequest {
    name: string;
    path?: string;
}

export interface CoreV1ApiConnectHeadNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectOptionsNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectOptionsNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectOptionsNodeProxyRequest {
    name: string;
    path?: string;
}

export interface CoreV1ApiConnectOptionsNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPatchNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPatchNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPatchNodeProxyRequest {
    name: string;
    path?: string;
}

export interface CoreV1ApiConnectPatchNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPostNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface CoreV1ApiConnectPostNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface CoreV1ApiConnectPostNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface CoreV1ApiConnectPostNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPostNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPostNodeProxyRequest {
    name: string;
    path?: string;
}

export interface CoreV1ApiConnectPostNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPutNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPutNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiConnectPutNodeProxyRequest {
    name: string;
    path?: string;
}

export interface CoreV1ApiConnectPutNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CoreV1ApiCreateNamespaceRequest {
    body: V1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedBindingRequest {
    namespace: string;
    body: V1Binding;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CoreV1ApiCreateNamespacedConfigMapRequest {
    namespace: string;
    body: V1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedEndpointsRequest {
    namespace: string;
    body: V1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedEventRequest {
    namespace: string;
    body: CoreV1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedLimitRangeRequest {
    namespace: string;
    body: V1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    body: V1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedPodRequest {
    namespace: string;
    body: V1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedPodBindingRequest {
    name: string;
    namespace: string;
    body: V1Binding;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CoreV1ApiCreateNamespacedPodEvictionRequest {
    name: string;
    namespace: string;
    body: V1Eviction;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CoreV1ApiCreateNamespacedPodTemplateRequest {
    namespace: string;
    body: V1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedReplicationControllerRequest {
    namespace: string;
    body: V1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedResourceQuotaRequest {
    namespace: string;
    body: V1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedSecretRequest {
    namespace: string;
    body: V1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedServiceRequest {
    namespace: string;
    body: V1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedServiceAccountRequest {
    namespace: string;
    body: V1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreateNamespacedServiceAccountTokenRequest {
    name: string;
    namespace: string;
    body: AuthenticationV1TokenRequest;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CoreV1ApiCreateNodeRequest {
    body: V1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiCreatePersistentVolumeRequest {
    body: V1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiDeleteCollectionNamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedEventRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedPodRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedServiceRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionNodeRequest {
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteCollectionPersistentVolumeRequest {
    pretty?: string;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespaceRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeleteNodeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiDeletePersistentVolumeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: V1DeleteOptions;
}

export interface CoreV1ApiListComponentStatusRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListConfigMapForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListEndpointsForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListEventForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListLimitRangeForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespaceRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedEventRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedPodRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedServiceRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListNodeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListPersistentVolumeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListPodForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListPodTemplateForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListReplicationControllerForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListResourceQuotaForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListSecretForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListServiceAccountForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiListServiceForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    resourceVersionMatch?: string;
    sendInitialEvents?: boolean;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface CoreV1ApiPatchNamespaceRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespaceStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedEventRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedPodRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedSecretRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedServiceRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNodeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchNodeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchPersistentVolumeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiPatchPersistentVolumeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    force?: boolean;
}

export interface CoreV1ApiReadComponentStatusRequest {
    name: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespaceRequest {
    name: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespaceStatusRequest {
    name: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedPodEphemeralcontainersRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedPodLogRequest {
    name: string;
    namespace: string;
    container?: string;
    follow?: boolean;
    insecureSkipTLSVerifyBackend?: boolean;
    limitBytes?: number;
    pretty?: string;
    previous?: boolean;
    sinceSeconds?: number;
    tailLines?: number;
    timestamps?: boolean;
}

export interface CoreV1ApiReadNamespacedPodStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface CoreV1ApiReadNodeRequest {
    name: string;
    pretty?: string;
}

export interface CoreV1ApiReadNodeStatusRequest {
    name: string;
    pretty?: string;
}

export interface CoreV1ApiReadPersistentVolumeRequest {
    name: string;
    pretty?: string;
}

export interface CoreV1ApiReadPersistentVolumeStatusRequest {
    name: string;
    pretty?: string;
}

export interface CoreV1ApiReplaceNamespaceRequest {
    name: string;
    body: V1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespaceFinalizeRequest {
    name: string;
    body: V1Namespace;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
    pretty?: string;
}

export interface CoreV1ApiReplaceNamespaceStatusRequest {
    name: string;
    body: V1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: V1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: V1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedEventRequest {
    name: string;
    namespace: string;
    body: CoreV1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: V1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: V1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: V1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedPodRequest {
    name: string;
    namespace: string;
    body: V1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest {
    name: string;
    namespace: string;
    body: V1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: V1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: V1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: V1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: V1Scale;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: V1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: V1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: V1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedSecretRequest {
    name: string;
    namespace: string;
    body: V1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedServiceRequest {
    name: string;
    namespace: string;
    body: V1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: V1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: V1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNodeRequest {
    name: string;
    body: V1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplaceNodeStatusRequest {
    name: string;
    body: V1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplacePersistentVolumeRequest {
    name: string;
    body: V1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

export interface CoreV1ApiReplacePersistentVolumeStatusRequest {
    name: string;
    body: V1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    fieldValidation?: string;
}

/**
 * 
 */
export class CoreV1Api extends runtime.BaseAPI {

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxyRaw(requestParameters: CoreV1ApiConnectDeleteNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectDeleteNamespacedPodProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectDeleteNamespacedPodProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxy(requestParameters: CoreV1ApiConnectDeleteNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectDeleteNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxyWithPathRaw(requestParameters: CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectDeleteNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectDeleteNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectDeleteNamespacedPodProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectDeleteNamespacedPodProxyWithPath(requestParameters: CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectDeleteNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxyRaw(requestParameters: CoreV1ApiConnectDeleteNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectDeleteNamespacedServiceProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectDeleteNamespacedServiceProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxy(requestParameters: CoreV1ApiConnectDeleteNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectDeleteNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxyWithPathRaw(requestParameters: CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectDeleteNamespacedServiceProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectDeleteNamespacedServiceProxyWithPath(requestParameters: CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectDeleteNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxyRaw(requestParameters: CoreV1ApiConnectDeleteNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectDeleteNodeProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxy(requestParameters: CoreV1ApiConnectDeleteNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectDeleteNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxyWithPathRaw(requestParameters: CoreV1ApiConnectDeleteNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectDeleteNodeProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectDeleteNodeProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectDeleteNodeProxyWithPath(requestParameters: CoreV1ApiConnectDeleteNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectDeleteNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectGetNamespacedPodAttachRaw(requestParameters: CoreV1ApiConnectGetNamespacedPodAttachRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNamespacedPodAttach().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectGetNamespacedPodAttach().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['container'] != null) {
            queryParameters['container'] = requestParameters['container'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['stdin'] != null) {
            queryParameters['stdin'] = requestParameters['stdin'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['tty'] != null) {
            queryParameters['tty'] = requestParameters['tty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectGetNamespacedPodAttach(requestParameters: CoreV1ApiConnectGetNamespacedPodAttachRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNamespacedPodAttachRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectGetNamespacedPodExecRaw(requestParameters: CoreV1ApiConnectGetNamespacedPodExecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNamespacedPodExec().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectGetNamespacedPodExec().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['command'] != null) {
            queryParameters['command'] = requestParameters['command'];
        }

        if (requestParameters['container'] != null) {
            queryParameters['container'] = requestParameters['container'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['stdin'] != null) {
            queryParameters['stdin'] = requestParameters['stdin'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['tty'] != null) {
            queryParameters['tty'] = requestParameters['tty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectGetNamespacedPodExec(requestParameters: CoreV1ApiConnectGetNamespacedPodExecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNamespacedPodExecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectGetNamespacedPodPortforwardRaw(requestParameters: CoreV1ApiConnectGetNamespacedPodPortforwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNamespacedPodPortforward().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectGetNamespacedPodPortforward().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ports'] != null) {
            queryParameters['ports'] = requestParameters['ports'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectGetNamespacedPodPortforward(requestParameters: CoreV1ApiConnectGetNamespacedPodPortforwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNamespacedPodPortforwardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxyRaw(requestParameters: CoreV1ApiConnectGetNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNamespacedPodProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectGetNamespacedPodProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxy(requestParameters: CoreV1ApiConnectGetNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxyWithPathRaw(requestParameters: CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectGetNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectGetNamespacedPodProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectGetNamespacedPodProxyWithPath(requestParameters: CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxyRaw(requestParameters: CoreV1ApiConnectGetNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNamespacedServiceProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectGetNamespacedServiceProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxy(requestParameters: CoreV1ApiConnectGetNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxyWithPathRaw(requestParameters: CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectGetNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectGetNamespacedServiceProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectGetNamespacedServiceProxyWithPath(requestParameters: CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxyRaw(requestParameters: CoreV1ApiConnectGetNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNodeProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxy(requestParameters: CoreV1ApiConnectGetNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxyWithPathRaw(requestParameters: CoreV1ApiConnectGetNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectGetNodeProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectGetNodeProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectGetNodeProxyWithPath(requestParameters: CoreV1ApiConnectGetNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectGetNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxyRaw(requestParameters: CoreV1ApiConnectHeadNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectHeadNamespacedPodProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectHeadNamespacedPodProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxy(requestParameters: CoreV1ApiConnectHeadNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectHeadNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxyWithPathRaw(requestParameters: CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectHeadNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectHeadNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectHeadNamespacedPodProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectHeadNamespacedPodProxyWithPath(requestParameters: CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectHeadNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxyRaw(requestParameters: CoreV1ApiConnectHeadNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectHeadNamespacedServiceProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectHeadNamespacedServiceProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxy(requestParameters: CoreV1ApiConnectHeadNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectHeadNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxyWithPathRaw(requestParameters: CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectHeadNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectHeadNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectHeadNamespacedServiceProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectHeadNamespacedServiceProxyWithPath(requestParameters: CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectHeadNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxyRaw(requestParameters: CoreV1ApiConnectHeadNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectHeadNodeProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxy(requestParameters: CoreV1ApiConnectHeadNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectHeadNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxyWithPathRaw(requestParameters: CoreV1ApiConnectHeadNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectHeadNodeProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectHeadNodeProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectHeadNodeProxyWithPath(requestParameters: CoreV1ApiConnectHeadNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectHeadNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxyRaw(requestParameters: CoreV1ApiConnectOptionsNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectOptionsNamespacedPodProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectOptionsNamespacedPodProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxy(requestParameters: CoreV1ApiConnectOptionsNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectOptionsNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxyWithPathRaw(requestParameters: CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectOptionsNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectOptionsNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectOptionsNamespacedPodProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectOptionsNamespacedPodProxyWithPath(requestParameters: CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectOptionsNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxyRaw(requestParameters: CoreV1ApiConnectOptionsNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectOptionsNamespacedServiceProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectOptionsNamespacedServiceProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxy(requestParameters: CoreV1ApiConnectOptionsNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectOptionsNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxyWithPathRaw(requestParameters: CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectOptionsNamespacedServiceProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectOptionsNamespacedServiceProxyWithPath(requestParameters: CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectOptionsNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxyRaw(requestParameters: CoreV1ApiConnectOptionsNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectOptionsNodeProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxy(requestParameters: CoreV1ApiConnectOptionsNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectOptionsNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxyWithPathRaw(requestParameters: CoreV1ApiConnectOptionsNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectOptionsNodeProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectOptionsNodeProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectOptionsNodeProxyWithPath(requestParameters: CoreV1ApiConnectOptionsNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectOptionsNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxyRaw(requestParameters: CoreV1ApiConnectPatchNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPatchNamespacedPodProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPatchNamespacedPodProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxy(requestParameters: CoreV1ApiConnectPatchNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPatchNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxyWithPathRaw(requestParameters: CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPatchNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPatchNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPatchNamespacedPodProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectPatchNamespacedPodProxyWithPath(requestParameters: CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPatchNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxyRaw(requestParameters: CoreV1ApiConnectPatchNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPatchNamespacedServiceProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPatchNamespacedServiceProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxy(requestParameters: CoreV1ApiConnectPatchNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPatchNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxyWithPathRaw(requestParameters: CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPatchNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPatchNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPatchNamespacedServiceProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectPatchNamespacedServiceProxyWithPath(requestParameters: CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPatchNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxyRaw(requestParameters: CoreV1ApiConnectPatchNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPatchNodeProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxy(requestParameters: CoreV1ApiConnectPatchNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPatchNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxyWithPathRaw(requestParameters: CoreV1ApiConnectPatchNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPatchNodeProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPatchNodeProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectPatchNodeProxyWithPath(requestParameters: CoreV1ApiConnectPatchNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPatchNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectPostNamespacedPodAttachRaw(requestParameters: CoreV1ApiConnectPostNamespacedPodAttachRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNamespacedPodAttach().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPostNamespacedPodAttach().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['container'] != null) {
            queryParameters['container'] = requestParameters['container'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['stdin'] != null) {
            queryParameters['stdin'] = requestParameters['stdin'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['tty'] != null) {
            queryParameters['tty'] = requestParameters['tty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectPostNamespacedPodAttach(requestParameters: CoreV1ApiConnectPostNamespacedPodAttachRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNamespacedPodAttachRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectPostNamespacedPodExecRaw(requestParameters: CoreV1ApiConnectPostNamespacedPodExecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNamespacedPodExec().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPostNamespacedPodExec().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['command'] != null) {
            queryParameters['command'] = requestParameters['command'];
        }

        if (requestParameters['container'] != null) {
            queryParameters['container'] = requestParameters['container'];
        }

        if (requestParameters['stderr'] != null) {
            queryParameters['stderr'] = requestParameters['stderr'];
        }

        if (requestParameters['stdin'] != null) {
            queryParameters['stdin'] = requestParameters['stdin'];
        }

        if (requestParameters['stdout'] != null) {
            queryParameters['stdout'] = requestParameters['stdout'];
        }

        if (requestParameters['tty'] != null) {
            queryParameters['tty'] = requestParameters['tty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectPostNamespacedPodExec(requestParameters: CoreV1ApiConnectPostNamespacedPodExecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNamespacedPodExecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectPostNamespacedPodPortforwardRaw(requestParameters: CoreV1ApiConnectPostNamespacedPodPortforwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNamespacedPodPortforward().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPostNamespacedPodPortforward().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ports'] != null) {
            queryParameters['ports'] = requestParameters['ports'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectPostNamespacedPodPortforward(requestParameters: CoreV1ApiConnectPostNamespacedPodPortforwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNamespacedPodPortforwardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxyRaw(requestParameters: CoreV1ApiConnectPostNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNamespacedPodProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPostNamespacedPodProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxy(requestParameters: CoreV1ApiConnectPostNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxyWithPathRaw(requestParameters: CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPostNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPostNamespacedPodProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectPostNamespacedPodProxyWithPath(requestParameters: CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxyRaw(requestParameters: CoreV1ApiConnectPostNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNamespacedServiceProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPostNamespacedServiceProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxy(requestParameters: CoreV1ApiConnectPostNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxyWithPathRaw(requestParameters: CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPostNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPostNamespacedServiceProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectPostNamespacedServiceProxyWithPath(requestParameters: CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxyRaw(requestParameters: CoreV1ApiConnectPostNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNodeProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxy(requestParameters: CoreV1ApiConnectPostNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxyWithPathRaw(requestParameters: CoreV1ApiConnectPostNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPostNodeProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPostNodeProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectPostNodeProxyWithPath(requestParameters: CoreV1ApiConnectPostNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPostNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxyRaw(requestParameters: CoreV1ApiConnectPutNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPutNamespacedPodProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPutNamespacedPodProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxy(requestParameters: CoreV1ApiConnectPutNamespacedPodProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPutNamespacedPodProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxyWithPathRaw(requestParameters: CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPutNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPutNamespacedPodProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPutNamespacedPodProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectPutNamespacedPodProxyWithPath(requestParameters: CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPutNamespacedPodProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxyRaw(requestParameters: CoreV1ApiConnectPutNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPutNamespacedServiceProxy().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPutNamespacedServiceProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxy(requestParameters: CoreV1ApiConnectPutNamespacedServiceProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPutNamespacedServiceProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxyWithPathRaw(requestParameters: CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPutNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling connectPutNamespacedServiceProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPutNamespacedServiceProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectPutNamespacedServiceProxyWithPath(requestParameters: CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPutNamespacedServiceProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxyRaw(requestParameters: CoreV1ApiConnectPutNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPutNodeProxy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxy(requestParameters: CoreV1ApiConnectPutNodeProxyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPutNodeProxyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxyWithPathRaw(requestParameters: CoreV1ApiConnectPutNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling connectPutNodeProxyWithPath().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling connectPutNodeProxyWithPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path2'] != null) {
            queryParameters['path'] = requestParameters['path2'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectPutNodeProxyWithPath(requestParameters: CoreV1ApiConnectPutNodeProxyWithPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.connectPutNodeProxyWithPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Namespace
     */
    async createNamespaceRaw(requestParameters: CoreV1ApiCreateNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * create a Namespace
     */
    async createNamespace(requestParameters: CoreV1ApiCreateNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.createNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Binding
     */
    async createNamespacedBindingRaw(requestParameters: CoreV1ApiCreateNamespacedBindingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Binding>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedBinding().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedBinding().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/bindings`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1BindingToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1BindingFromJSON(jsonValue));
    }

    /**
     * create a Binding
     */
    async createNamespacedBinding(requestParameters: CoreV1ApiCreateNamespacedBindingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Binding> {
        const response = await this.createNamespacedBindingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ConfigMap
     */
    async createNamespacedConfigMapRaw(requestParameters: CoreV1ApiCreateNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedConfigMap().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedConfigMap().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ConfigMapToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * create a ConfigMap
     */
    async createNamespacedConfigMap(requestParameters: CoreV1ApiCreateNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ConfigMap> {
        const response = await this.createNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create Endpoints
     */
    async createNamespacedEndpointsRaw(requestParameters: CoreV1ApiCreateNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedEndpoints().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedEndpoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1EndpointsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * create Endpoints
     */
    async createNamespacedEndpoints(requestParameters: CoreV1ApiCreateNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Endpoints> {
        const response = await this.createNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create an Event
     */
    async createNamespacedEventRaw(requestParameters: CoreV1ApiCreateNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CoreV1Event>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedEvent().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CoreV1EventToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreV1EventFromJSON(jsonValue));
    }

    /**
     * create an Event
     */
    async createNamespacedEvent(requestParameters: CoreV1ApiCreateNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CoreV1Event> {
        const response = await this.createNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a LimitRange
     */
    async createNamespacedLimitRangeRaw(requestParameters: CoreV1ApiCreateNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedLimitRange().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedLimitRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1LimitRangeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * create a LimitRange
     */
    async createNamespacedLimitRange(requestParameters: CoreV1ApiCreateNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1LimitRange> {
        const response = await this.createNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createNamespacedPersistentVolumeClaimRaw(requestParameters: CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedPersistentVolumeClaim().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedPersistentVolumeClaim().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeClaimToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createNamespacedPersistentVolumeClaim(requestParameters: CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.createNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Pod
     */
    async createNamespacedPodRaw(requestParameters: CoreV1ApiCreateNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedPod().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedPod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * create a Pod
     */
    async createNamespacedPod(requestParameters: CoreV1ApiCreateNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.createNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create binding of a Pod
     */
    async createNamespacedPodBindingRaw(requestParameters: CoreV1ApiCreateNamespacedPodBindingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Binding>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling createNamespacedPodBinding().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedPodBinding().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedPodBinding().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/binding`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1BindingToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1BindingFromJSON(jsonValue));
    }

    /**
     * create binding of a Pod
     */
    async createNamespacedPodBinding(requestParameters: CoreV1ApiCreateNamespacedPodBindingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Binding> {
        const response = await this.createNamespacedPodBindingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create eviction of a Pod
     */
    async createNamespacedPodEvictionRaw(requestParameters: CoreV1ApiCreateNamespacedPodEvictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Eviction>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling createNamespacedPodEviction().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedPodEviction().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedPodEviction().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/eviction`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1EvictionToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EvictionFromJSON(jsonValue));
    }

    /**
     * create eviction of a Pod
     */
    async createNamespacedPodEviction(requestParameters: CoreV1ApiCreateNamespacedPodEvictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Eviction> {
        const response = await this.createNamespacedPodEvictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a PodTemplate
     */
    async createNamespacedPodTemplateRaw(requestParameters: CoreV1ApiCreateNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedPodTemplate().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedPodTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodTemplateToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * create a PodTemplate
     */
    async createNamespacedPodTemplate(requestParameters: CoreV1ApiCreateNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodTemplate> {
        const response = await this.createNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ReplicationController
     */
    async createNamespacedReplicationControllerRaw(requestParameters: CoreV1ApiCreateNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedReplicationController().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedReplicationController().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ReplicationControllerToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * create a ReplicationController
     */
    async createNamespacedReplicationController(requestParameters: CoreV1ApiCreateNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationController> {
        const response = await this.createNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ResourceQuota
     */
    async createNamespacedResourceQuotaRaw(requestParameters: CoreV1ApiCreateNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedResourceQuota().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedResourceQuota().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ResourceQuotaToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * create a ResourceQuota
     */
    async createNamespacedResourceQuota(requestParameters: CoreV1ApiCreateNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.createNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Secret
     */
    async createNamespacedSecretRaw(requestParameters: CoreV1ApiCreateNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedSecret().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedSecret().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1SecretToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * create a Secret
     */
    async createNamespacedSecret(requestParameters: CoreV1ApiCreateNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Secret> {
        const response = await this.createNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Service
     */
    async createNamespacedServiceRaw(requestParameters: CoreV1ApiCreateNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedService().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedService().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * create a Service
     */
    async createNamespacedService(requestParameters: CoreV1ApiCreateNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.createNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a ServiceAccount
     */
    async createNamespacedServiceAccountRaw(requestParameters: CoreV1ApiCreateNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedServiceAccount().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedServiceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceAccountToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * create a ServiceAccount
     */
    async createNamespacedServiceAccount(requestParameters: CoreV1ApiCreateNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceAccount> {
        const response = await this.createNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create token of a ServiceAccount
     */
    async createNamespacedServiceAccountTokenRaw(requestParameters: CoreV1ApiCreateNamespacedServiceAccountTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationV1TokenRequest>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling createNamespacedServiceAccountToken().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling createNamespacedServiceAccountToken().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNamespacedServiceAccountToken().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthenticationV1TokenRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationV1TokenRequestFromJSON(jsonValue));
    }

    /**
     * create token of a ServiceAccount
     */
    async createNamespacedServiceAccountToken(requestParameters: CoreV1ApiCreateNamespacedServiceAccountTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationV1TokenRequest> {
        const response = await this.createNamespacedServiceAccountTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a Node
     */
    async createNodeRaw(requestParameters: CoreV1ApiCreateNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createNode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1NodeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * create a Node
     */
    async createNode(requestParameters: CoreV1ApiCreateNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Node> {
        const response = await this.createNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a PersistentVolume
     */
    async createPersistentVolumeRaw(requestParameters: CoreV1ApiCreatePersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createPersistentVolume().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolume
     */
    async createPersistentVolume(requestParameters: CoreV1ApiCreatePersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.createPersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCollectionNamespacedConfigMapRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedConfigMap().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCollectionNamespacedConfigMap(requestParameters: CoreV1ApiDeleteCollectionNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCollectionNamespacedEndpointsRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedEndpoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCollectionNamespacedEndpoints(requestParameters: CoreV1ApiDeleteCollectionNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Event
     */
    async deleteCollectionNamespacedEventRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Event
     */
    async deleteCollectionNamespacedEvent(requestParameters: CoreV1ApiDeleteCollectionNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCollectionNamespacedLimitRangeRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedLimitRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCollectionNamespacedLimitRange(requestParameters: CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCollectionNamespacedPersistentVolumeClaimRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedPersistentVolumeClaim().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCollectionNamespacedPersistentVolumeClaim(requestParameters: CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Pod
     */
    async deleteCollectionNamespacedPodRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedPod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Pod
     */
    async deleteCollectionNamespacedPod(requestParameters: CoreV1ApiDeleteCollectionNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCollectionNamespacedPodTemplateRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedPodTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCollectionNamespacedPodTemplate(requestParameters: CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCollectionNamespacedReplicationControllerRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedReplicationController().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCollectionNamespacedReplicationController(requestParameters: CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCollectionNamespacedResourceQuotaRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedResourceQuota().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCollectionNamespacedResourceQuota(requestParameters: CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Secret
     */
    async deleteCollectionNamespacedSecretRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedSecret().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Secret
     */
    async deleteCollectionNamespacedSecret(requestParameters: CoreV1ApiDeleteCollectionNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Service
     */
    async deleteCollectionNamespacedServiceRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedService().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Service
     */
    async deleteCollectionNamespacedService(requestParameters: CoreV1ApiDeleteCollectionNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCollectionNamespacedServiceAccountRaw(requestParameters: CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteCollectionNamespacedServiceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCollectionNamespacedServiceAccount(requestParameters: CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of Node
     */
    async deleteCollectionNodeRaw(requestParameters: CoreV1ApiDeleteCollectionNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Node
     */
    async deleteCollectionNode(requestParameters: CoreV1ApiDeleteCollectionNodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCollectionPersistentVolumeRaw(requestParameters: CoreV1ApiDeleteCollectionPersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCollectionPersistentVolume(requestParameters: CoreV1ApiDeleteCollectionPersistentVolumeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteCollectionPersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Namespace
     */
    async deleteNamespaceRaw(requestParameters: CoreV1ApiDeleteNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Namespace
     */
    async deleteNamespace(requestParameters: CoreV1ApiDeleteNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ConfigMap
     */
    async deleteNamespacedConfigMapRaw(requestParameters: CoreV1ApiDeleteNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedConfigMap().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedConfigMap().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ConfigMap
     */
    async deleteNamespacedConfigMap(requestParameters: CoreV1ApiDeleteNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete Endpoints
     */
    async deleteNamespacedEndpointsRaw(requestParameters: CoreV1ApiDeleteNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedEndpoints().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedEndpoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete Endpoints
     */
    async deleteNamespacedEndpoints(requestParameters: CoreV1ApiDeleteNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete an Event
     */
    async deleteNamespacedEventRaw(requestParameters: CoreV1ApiDeleteNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedEvent().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete an Event
     */
    async deleteNamespacedEvent(requestParameters: CoreV1ApiDeleteNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a LimitRange
     */
    async deleteNamespacedLimitRangeRaw(requestParameters: CoreV1ApiDeleteNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedLimitRange().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedLimitRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a LimitRange
     */
    async deleteNamespacedLimitRange(requestParameters: CoreV1ApiDeleteNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteNamespacedPersistentVolumeClaimRaw(requestParameters: CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedPersistentVolumeClaim().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedPersistentVolumeClaim().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteNamespacedPersistentVolumeClaim(requestParameters: CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.deleteNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Pod
     */
    async deleteNamespacedPodRaw(requestParameters: CoreV1ApiDeleteNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedPod().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedPod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * delete a Pod
     */
    async deleteNamespacedPod(requestParameters: CoreV1ApiDeleteNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.deleteNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a PodTemplate
     */
    async deleteNamespacedPodTemplateRaw(requestParameters: CoreV1ApiDeleteNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedPodTemplate().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedPodTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * delete a PodTemplate
     */
    async deleteNamespacedPodTemplate(requestParameters: CoreV1ApiDeleteNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodTemplate> {
        const response = await this.deleteNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ReplicationController
     */
    async deleteNamespacedReplicationControllerRaw(requestParameters: CoreV1ApiDeleteNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedReplicationController().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedReplicationController().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ReplicationController
     */
    async deleteNamespacedReplicationController(requestParameters: CoreV1ApiDeleteNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ResourceQuota
     */
    async deleteNamespacedResourceQuotaRaw(requestParameters: CoreV1ApiDeleteNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedResourceQuota().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedResourceQuota().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * delete a ResourceQuota
     */
    async deleteNamespacedResourceQuota(requestParameters: CoreV1ApiDeleteNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.deleteNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Secret
     */
    async deleteNamespacedSecretRaw(requestParameters: CoreV1ApiDeleteNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedSecret().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedSecret().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Secret
     */
    async deleteNamespacedSecret(requestParameters: CoreV1ApiDeleteNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Service
     */
    async deleteNamespacedServiceRaw(requestParameters: CoreV1ApiDeleteNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedService().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedService().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * delete a Service
     */
    async deleteNamespacedService(requestParameters: CoreV1ApiDeleteNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.deleteNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a ServiceAccount
     */
    async deleteNamespacedServiceAccountRaw(requestParameters: CoreV1ApiDeleteNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNamespacedServiceAccount().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling deleteNamespacedServiceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * delete a ServiceAccount
     */
    async deleteNamespacedServiceAccount(requestParameters: CoreV1ApiDeleteNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceAccount> {
        const response = await this.deleteNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a Node
     */
    async deleteNodeRaw(requestParameters: CoreV1ApiDeleteNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Status>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteNode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Node
     */
    async deleteNode(requestParameters: CoreV1ApiDeleteNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Status> {
        const response = await this.deleteNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * delete a PersistentVolume
     */
    async deletePersistentVolumeRaw(requestParameters: CoreV1ApiDeletePersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deletePersistentVolume().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['gracePeriodSeconds'] != null) {
            queryParameters['gracePeriodSeconds'] = requestParameters['gracePeriodSeconds'];
        }

        if (requestParameters['orphanDependents'] != null) {
            queryParameters['orphanDependents'] = requestParameters['orphanDependents'];
        }

        if (requestParameters['propagationPolicy'] != null) {
            queryParameters['propagationPolicy'] = requestParameters['propagationPolicy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: V1DeleteOptionsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolume
     */
    async deletePersistentVolume(requestParameters: CoreV1ApiDeletePersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.deletePersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get available resources
     */
    async getAPIResourcesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1APIResourceList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1APIResourceListFromJSON(jsonValue));
    }

    /**
     * get available resources
     */
    async getAPIResources(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1APIResourceList> {
        const response = await this.getAPIResourcesRaw(initOverrides);
        return await response.value();
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listComponentStatusRaw(requestParameters: CoreV1ApiListComponentStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ComponentStatusList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ComponentStatusListFromJSON(jsonValue));
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listComponentStatus(requestParameters: CoreV1ApiListComponentStatusRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ComponentStatusList> {
        const response = await this.listComponentStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listConfigMapForAllNamespacesRaw(requestParameters: CoreV1ApiListConfigMapForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ConfigMapList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/configmaps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listConfigMapForAllNamespaces(requestParameters: CoreV1ApiListConfigMapForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ConfigMapList> {
        const response = await this.listConfigMapForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listEndpointsForAllNamespacesRaw(requestParameters: CoreV1ApiListEndpointsForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1EndpointsList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/endpoints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listEndpointsForAllNamespaces(requestParameters: CoreV1ApiListEndpointsForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1EndpointsList> {
        const response = await this.listEndpointsForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listEventForAllNamespacesRaw(requestParameters: CoreV1ApiListEventForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CoreV1EventList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreV1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listEventForAllNamespaces(requestParameters: CoreV1ApiListEventForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CoreV1EventList> {
        const response = await this.listEventForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listLimitRangeForAllNamespacesRaw(requestParameters: CoreV1ApiListLimitRangeForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1LimitRangeList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/limitranges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listLimitRangeForAllNamespaces(requestParameters: CoreV1ApiListLimitRangeForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1LimitRangeList> {
        const response = await this.listLimitRangeForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listNamespaceRaw(requestParameters: CoreV1ApiListNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1NamespaceList>> {
        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listNamespace(requestParameters: CoreV1ApiListNamespaceRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1NamespaceList> {
        const response = await this.listNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listNamespacedConfigMapRaw(requestParameters: CoreV1ApiListNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ConfigMapList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedConfigMap().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listNamespacedConfigMap(requestParameters: CoreV1ApiListNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ConfigMapList> {
        const response = await this.listNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listNamespacedEndpointsRaw(requestParameters: CoreV1ApiListNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1EndpointsList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedEndpoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listNamespacedEndpoints(requestParameters: CoreV1ApiListNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1EndpointsList> {
        const response = await this.listNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listNamespacedEventRaw(requestParameters: CoreV1ApiListNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CoreV1EventList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreV1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listNamespacedEvent(requestParameters: CoreV1ApiListNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CoreV1EventList> {
        const response = await this.listNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listNamespacedLimitRangeRaw(requestParameters: CoreV1ApiListNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1LimitRangeList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedLimitRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listNamespacedLimitRange(requestParameters: CoreV1ApiListNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1LimitRangeList> {
        const response = await this.listNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listNamespacedPersistentVolumeClaimRaw(requestParameters: CoreV1ApiListNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaimList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedPersistentVolumeClaim().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listNamespacedPersistentVolumeClaim(requestParameters: CoreV1ApiListNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaimList> {
        const response = await this.listNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listNamespacedPodRaw(requestParameters: CoreV1ApiListNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedPod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listNamespacedPod(requestParameters: CoreV1ApiListNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodList> {
        const response = await this.listNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listNamespacedPodTemplateRaw(requestParameters: CoreV1ApiListNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodTemplateList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedPodTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listNamespacedPodTemplate(requestParameters: CoreV1ApiListNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodTemplateList> {
        const response = await this.listNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listNamespacedReplicationControllerRaw(requestParameters: CoreV1ApiListNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationControllerList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedReplicationController().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listNamespacedReplicationController(requestParameters: CoreV1ApiListNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationControllerList> {
        const response = await this.listNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listNamespacedResourceQuotaRaw(requestParameters: CoreV1ApiListNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuotaList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedResourceQuota().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listNamespacedResourceQuota(requestParameters: CoreV1ApiListNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuotaList> {
        const response = await this.listNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listNamespacedSecretRaw(requestParameters: CoreV1ApiListNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1SecretList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedSecret().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listNamespacedSecret(requestParameters: CoreV1ApiListNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1SecretList> {
        const response = await this.listNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listNamespacedServiceRaw(requestParameters: CoreV1ApiListNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedService().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listNamespacedService(requestParameters: CoreV1ApiListNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceList> {
        const response = await this.listNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listNamespacedServiceAccountRaw(requestParameters: CoreV1ApiListNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceAccountList>> {
        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling listNamespacedServiceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listNamespacedServiceAccount(requestParameters: CoreV1ApiListNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceAccountList> {
        const response = await this.listNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Node
     */
    async listNodeRaw(requestParameters: CoreV1ApiListNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1NodeList>> {
        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Node
     */
    async listNode(requestParameters: CoreV1ApiListNodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1NodeList> {
        const response = await this.listNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listPersistentVolumeRaw(requestParameters: CoreV1ApiListPersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeList>> {
        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listPersistentVolume(requestParameters: CoreV1ApiListPersistentVolumeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeList> {
        const response = await this.listPersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listPersistentVolumeClaimForAllNamespacesRaw(requestParameters: CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaimList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumeclaims`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listPersistentVolumeClaimForAllNamespaces(requestParameters: CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaimList> {
        const response = await this.listPersistentVolumeClaimForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listPodForAllNamespacesRaw(requestParameters: CoreV1ApiListPodForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/pods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listPodForAllNamespaces(requestParameters: CoreV1ApiListPodForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodList> {
        const response = await this.listPodForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listPodTemplateForAllNamespacesRaw(requestParameters: CoreV1ApiListPodTemplateForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodTemplateList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/podtemplates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listPodTemplateForAllNamespaces(requestParameters: CoreV1ApiListPodTemplateForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodTemplateList> {
        const response = await this.listPodTemplateForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listReplicationControllerForAllNamespacesRaw(requestParameters: CoreV1ApiListReplicationControllerForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationControllerList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/replicationcontrollers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listReplicationControllerForAllNamespaces(requestParameters: CoreV1ApiListReplicationControllerForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationControllerList> {
        const response = await this.listReplicationControllerForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listResourceQuotaForAllNamespacesRaw(requestParameters: CoreV1ApiListResourceQuotaForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuotaList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/resourcequotas`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listResourceQuotaForAllNamespaces(requestParameters: CoreV1ApiListResourceQuotaForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuotaList> {
        const response = await this.listResourceQuotaForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listSecretForAllNamespacesRaw(requestParameters: CoreV1ApiListSecretForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1SecretList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/secrets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listSecretForAllNamespaces(requestParameters: CoreV1ApiListSecretForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1SecretList> {
        const response = await this.listSecretForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listServiceAccountForAllNamespacesRaw(requestParameters: CoreV1ApiListServiceAccountForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceAccountList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/serviceaccounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listServiceAccountForAllNamespaces(requestParameters: CoreV1ApiListServiceAccountForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceAccountList> {
        const response = await this.listServiceAccountForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listServiceForAllNamespacesRaw(requestParameters: CoreV1ApiListServiceForAllNamespacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceList>> {
        const queryParameters: any = {};

        if (requestParameters['allowWatchBookmarks'] != null) {
            queryParameters['allowWatchBookmarks'] = requestParameters['allowWatchBookmarks'];
        }

        if (requestParameters['_continue'] != null) {
            queryParameters['continue'] = requestParameters['_continue'];
        }

        if (requestParameters['fieldSelector'] != null) {
            queryParameters['fieldSelector'] = requestParameters['fieldSelector'];
        }

        if (requestParameters['labelSelector'] != null) {
            queryParameters['labelSelector'] = requestParameters['labelSelector'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['resourceVersion'] != null) {
            queryParameters['resourceVersion'] = requestParameters['resourceVersion'];
        }

        if (requestParameters['resourceVersionMatch'] != null) {
            queryParameters['resourceVersionMatch'] = requestParameters['resourceVersionMatch'];
        }

        if (requestParameters['sendInitialEvents'] != null) {
            queryParameters['sendInitialEvents'] = requestParameters['sendInitialEvents'];
        }

        if (requestParameters['timeoutSeconds'] != null) {
            queryParameters['timeoutSeconds'] = requestParameters['timeoutSeconds'];
        }

        if (requestParameters['watch'] != null) {
            queryParameters['watch'] = requestParameters['watch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/services`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listServiceForAllNamespaces(requestParameters: CoreV1ApiListServiceForAllNamespacesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceList> {
        const response = await this.listServiceForAllNamespacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Namespace
     */
    async patchNamespaceRaw(requestParameters: CoreV1ApiPatchNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespace().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Namespace
     */
    async patchNamespace(requestParameters: CoreV1ApiPatchNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.patchNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchNamespaceStatusRaw(requestParameters: CoreV1ApiPatchNamespaceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespaceStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespaceStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchNamespaceStatus(requestParameters: CoreV1ApiPatchNamespaceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.patchNamespaceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchNamespacedConfigMapRaw(requestParameters: CoreV1ApiPatchNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedConfigMap().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedConfigMap().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedConfigMap().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchNamespacedConfigMap(requestParameters: CoreV1ApiPatchNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ConfigMap> {
        const response = await this.patchNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Endpoints
     */
    async patchNamespacedEndpointsRaw(requestParameters: CoreV1ApiPatchNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedEndpoints().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedEndpoints().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedEndpoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * partially update the specified Endpoints
     */
    async patchNamespacedEndpoints(requestParameters: CoreV1ApiPatchNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Endpoints> {
        const response = await this.patchNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Event
     */
    async patchNamespacedEventRaw(requestParameters: CoreV1ApiPatchNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CoreV1Event>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedEvent().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedEvent().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreV1EventFromJSON(jsonValue));
    }

    /**
     * partially update the specified Event
     */
    async patchNamespacedEvent(requestParameters: CoreV1ApiPatchNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CoreV1Event> {
        const response = await this.patchNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified LimitRange
     */
    async patchNamespacedLimitRangeRaw(requestParameters: CoreV1ApiPatchNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedLimitRange().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedLimitRange().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedLimitRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * partially update the specified LimitRange
     */
    async patchNamespacedLimitRange(requestParameters: CoreV1ApiPatchNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1LimitRange> {
        const response = await this.patchNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaimRaw(requestParameters: CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedPersistentVolumeClaim().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedPersistentVolumeClaim().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedPersistentVolumeClaim().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaim(requestParameters: CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.patchNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaimStatusRaw(requestParameters: CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedPersistentVolumeClaimStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchNamespacedPersistentVolumeClaimStatus(requestParameters: CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.patchNamespacedPersistentVolumeClaimStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Pod
     */
    async patchNamespacedPodRaw(requestParameters: CoreV1ApiPatchNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedPod().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedPod().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedPod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * partially update the specified Pod
     */
    async patchNamespacedPod(requestParameters: CoreV1ApiPatchNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.patchNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     */
    async patchNamespacedPodEphemeralcontainersRaw(requestParameters: CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedPodEphemeralcontainers().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedPodEphemeralcontainers().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedPodEphemeralcontainers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     */
    async patchNamespacedPodEphemeralcontainers(requestParameters: CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.patchNamespacedPodEphemeralcontainersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Pod
     */
    async patchNamespacedPodStatusRaw(requestParameters: CoreV1ApiPatchNamespacedPodStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedPodStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedPodStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedPodStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Pod
     */
    async patchNamespacedPodStatus(requestParameters: CoreV1ApiPatchNamespacedPodStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.patchNamespacedPodStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchNamespacedPodTemplateRaw(requestParameters: CoreV1ApiPatchNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedPodTemplate().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedPodTemplate().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedPodTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchNamespacedPodTemplate(requestParameters: CoreV1ApiPatchNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodTemplate> {
        const response = await this.patchNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchNamespacedReplicationControllerRaw(requestParameters: CoreV1ApiPatchNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedReplicationController().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedReplicationController().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedReplicationController().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchNamespacedReplicationController(requestParameters: CoreV1ApiPatchNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationController> {
        const response = await this.patchNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerScaleRaw(requestParameters: CoreV1ApiPatchNamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Scale>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedReplicationControllerScale().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedReplicationControllerScale().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedReplicationControllerScale().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ScaleFromJSON(jsonValue));
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerScale(requestParameters: CoreV1ApiPatchNamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Scale> {
        const response = await this.patchNamespacedReplicationControllerScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerStatusRaw(requestParameters: CoreV1ApiPatchNamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedReplicationControllerStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedReplicationControllerStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedReplicationControllerStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchNamespacedReplicationControllerStatus(requestParameters: CoreV1ApiPatchNamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationController> {
        const response = await this.patchNamespacedReplicationControllerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchNamespacedResourceQuotaRaw(requestParameters: CoreV1ApiPatchNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedResourceQuota().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedResourceQuota().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedResourceQuota().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchNamespacedResourceQuota(requestParameters: CoreV1ApiPatchNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.patchNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchNamespacedResourceQuotaStatusRaw(requestParameters: CoreV1ApiPatchNamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedResourceQuotaStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedResourceQuotaStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedResourceQuotaStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchNamespacedResourceQuotaStatus(requestParameters: CoreV1ApiPatchNamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.patchNamespacedResourceQuotaStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Secret
     */
    async patchNamespacedSecretRaw(requestParameters: CoreV1ApiPatchNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedSecret().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedSecret().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedSecret().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * partially update the specified Secret
     */
    async patchNamespacedSecret(requestParameters: CoreV1ApiPatchNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Secret> {
        const response = await this.patchNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Service
     */
    async patchNamespacedServiceRaw(requestParameters: CoreV1ApiPatchNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedService().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedService().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedService().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Service
     */
    async patchNamespacedService(requestParameters: CoreV1ApiPatchNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.patchNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchNamespacedServiceAccountRaw(requestParameters: CoreV1ApiPatchNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedServiceAccount().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedServiceAccount().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedServiceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchNamespacedServiceAccount(requestParameters: CoreV1ApiPatchNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceAccount> {
        const response = await this.patchNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Service
     */
    async patchNamespacedServiceStatusRaw(requestParameters: CoreV1ApiPatchNamespacedServiceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNamespacedServiceStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling patchNamespacedServiceStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNamespacedServiceStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Service
     */
    async patchNamespacedServiceStatus(requestParameters: CoreV1ApiPatchNamespacedServiceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.patchNamespacedServiceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified Node
     */
    async patchNodeRaw(requestParameters: CoreV1ApiPatchNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNode().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * partially update the specified Node
     */
    async patchNode(requestParameters: CoreV1ApiPatchNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Node> {
        const response = await this.patchNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified Node
     */
    async patchNodeStatusRaw(requestParameters: CoreV1ApiPatchNodeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchNodeStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchNodeStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Node
     */
    async patchNodeStatus(requestParameters: CoreV1ApiPatchNodeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Node> {
        const response = await this.patchNodeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchPersistentVolumeRaw(requestParameters: CoreV1ApiPatchPersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchPersistentVolume().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchPersistentVolume().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchPersistentVolume(requestParameters: CoreV1ApiPatchPersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.patchPersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchPersistentVolumeStatusRaw(requestParameters: CoreV1ApiPatchPersistentVolumeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling patchPersistentVolumeStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchPersistentVolumeStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchPersistentVolumeStatus(requestParameters: CoreV1ApiPatchPersistentVolumeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.patchPersistentVolumeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ComponentStatus
     */
    async readComponentStatusRaw(requestParameters: CoreV1ApiReadComponentStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ComponentStatus>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readComponentStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ComponentStatusFromJSON(jsonValue));
    }

    /**
     * read the specified ComponentStatus
     */
    async readComponentStatus(requestParameters: CoreV1ApiReadComponentStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ComponentStatus> {
        const response = await this.readComponentStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Namespace
     */
    async readNamespaceRaw(requestParameters: CoreV1ApiReadNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * read the specified Namespace
     */
    async readNamespace(requestParameters: CoreV1ApiReadNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.readNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Namespace
     */
    async readNamespaceStatusRaw(requestParameters: CoreV1ApiReadNamespaceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespaceStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Namespace
     */
    async readNamespaceStatus(requestParameters: CoreV1ApiReadNamespaceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.readNamespaceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ConfigMap
     */
    async readNamespacedConfigMapRaw(requestParameters: CoreV1ApiReadNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedConfigMap().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedConfigMap().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * read the specified ConfigMap
     */
    async readNamespacedConfigMap(requestParameters: CoreV1ApiReadNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ConfigMap> {
        const response = await this.readNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Endpoints
     */
    async readNamespacedEndpointsRaw(requestParameters: CoreV1ApiReadNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedEndpoints().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedEndpoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * read the specified Endpoints
     */
    async readNamespacedEndpoints(requestParameters: CoreV1ApiReadNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Endpoints> {
        const response = await this.readNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Event
     */
    async readNamespacedEventRaw(requestParameters: CoreV1ApiReadNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CoreV1Event>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedEvent().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreV1EventFromJSON(jsonValue));
    }

    /**
     * read the specified Event
     */
    async readNamespacedEvent(requestParameters: CoreV1ApiReadNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CoreV1Event> {
        const response = await this.readNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified LimitRange
     */
    async readNamespacedLimitRangeRaw(requestParameters: CoreV1ApiReadNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedLimitRange().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedLimitRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * read the specified LimitRange
     */
    async readNamespacedLimitRange(requestParameters: CoreV1ApiReadNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1LimitRange> {
        const response = await this.readNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaimRaw(requestParameters: CoreV1ApiReadNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedPersistentVolumeClaim().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedPersistentVolumeClaim().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaim(requestParameters: CoreV1ApiReadNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.readNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaimStatusRaw(requestParameters: CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedPersistentVolumeClaimStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedPersistentVolumeClaimStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readNamespacedPersistentVolumeClaimStatus(requestParameters: CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.readNamespacedPersistentVolumeClaimStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Pod
     */
    async readNamespacedPodRaw(requestParameters: CoreV1ApiReadNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedPod().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedPod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * read the specified Pod
     */
    async readNamespacedPod(requestParameters: CoreV1ApiReadNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.readNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read ephemeralcontainers of the specified Pod
     */
    async readNamespacedPodEphemeralcontainersRaw(requestParameters: CoreV1ApiReadNamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedPodEphemeralcontainers().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedPodEphemeralcontainers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * read ephemeralcontainers of the specified Pod
     */
    async readNamespacedPodEphemeralcontainers(requestParameters: CoreV1ApiReadNamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.readNamespacedPodEphemeralcontainersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read log of the specified Pod
     */
    async readNamespacedPodLogRaw(requestParameters: CoreV1ApiReadNamespacedPodLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedPodLog().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedPodLog().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['container'] != null) {
            queryParameters['container'] = requestParameters['container'];
        }

        if (requestParameters['follow'] != null) {
            queryParameters['follow'] = requestParameters['follow'];
        }

        if (requestParameters['insecureSkipTLSVerifyBackend'] != null) {
            queryParameters['insecureSkipTLSVerifyBackend'] = requestParameters['insecureSkipTLSVerifyBackend'];
        }

        if (requestParameters['limitBytes'] != null) {
            queryParameters['limitBytes'] = requestParameters['limitBytes'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['previous'] != null) {
            queryParameters['previous'] = requestParameters['previous'];
        }

        if (requestParameters['sinceSeconds'] != null) {
            queryParameters['sinceSeconds'] = requestParameters['sinceSeconds'];
        }

        if (requestParameters['tailLines'] != null) {
            queryParameters['tailLines'] = requestParameters['tailLines'];
        }

        if (requestParameters['timestamps'] != null) {
            queryParameters['timestamps'] = requestParameters['timestamps'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/log`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * read log of the specified Pod
     */
    async readNamespacedPodLog(requestParameters: CoreV1ApiReadNamespacedPodLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.readNamespacedPodLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Pod
     */
    async readNamespacedPodStatusRaw(requestParameters: CoreV1ApiReadNamespacedPodStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedPodStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedPodStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * read status of the specified Pod
     */
    async readNamespacedPodStatus(requestParameters: CoreV1ApiReadNamespacedPodStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.readNamespacedPodStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified PodTemplate
     */
    async readNamespacedPodTemplateRaw(requestParameters: CoreV1ApiReadNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedPodTemplate().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedPodTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * read the specified PodTemplate
     */
    async readNamespacedPodTemplate(requestParameters: CoreV1ApiReadNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodTemplate> {
        const response = await this.readNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ReplicationController
     */
    async readNamespacedReplicationControllerRaw(requestParameters: CoreV1ApiReadNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedReplicationController().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedReplicationController().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read the specified ReplicationController
     */
    async readNamespacedReplicationController(requestParameters: CoreV1ApiReadNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationController> {
        const response = await this.readNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readNamespacedReplicationControllerScaleRaw(requestParameters: CoreV1ApiReadNamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Scale>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedReplicationControllerScale().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedReplicationControllerScale().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ScaleFromJSON(jsonValue));
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readNamespacedReplicationControllerScale(requestParameters: CoreV1ApiReadNamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Scale> {
        const response = await this.readNamespacedReplicationControllerScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified ReplicationController
     */
    async readNamespacedReplicationControllerStatusRaw(requestParameters: CoreV1ApiReadNamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedReplicationControllerStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedReplicationControllerStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read status of the specified ReplicationController
     */
    async readNamespacedReplicationControllerStatus(requestParameters: CoreV1ApiReadNamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationController> {
        const response = await this.readNamespacedReplicationControllerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ResourceQuota
     */
    async readNamespacedResourceQuotaRaw(requestParameters: CoreV1ApiReadNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedResourceQuota().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedResourceQuota().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read the specified ResourceQuota
     */
    async readNamespacedResourceQuota(requestParameters: CoreV1ApiReadNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.readNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readNamespacedResourceQuotaStatusRaw(requestParameters: CoreV1ApiReadNamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedResourceQuotaStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedResourceQuotaStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readNamespacedResourceQuotaStatus(requestParameters: CoreV1ApiReadNamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.readNamespacedResourceQuotaStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Secret
     */
    async readNamespacedSecretRaw(requestParameters: CoreV1ApiReadNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedSecret().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedSecret().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * read the specified Secret
     */
    async readNamespacedSecret(requestParameters: CoreV1ApiReadNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Secret> {
        const response = await this.readNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Service
     */
    async readNamespacedServiceRaw(requestParameters: CoreV1ApiReadNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedService().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedService().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * read the specified Service
     */
    async readNamespacedService(requestParameters: CoreV1ApiReadNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.readNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified ServiceAccount
     */
    async readNamespacedServiceAccountRaw(requestParameters: CoreV1ApiReadNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedServiceAccount().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedServiceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * read the specified ServiceAccount
     */
    async readNamespacedServiceAccount(requestParameters: CoreV1ApiReadNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceAccount> {
        const response = await this.readNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Service
     */
    async readNamespacedServiceStatusRaw(requestParameters: CoreV1ApiReadNamespacedServiceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNamespacedServiceStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling readNamespacedServiceStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Service
     */
    async readNamespacedServiceStatus(requestParameters: CoreV1ApiReadNamespacedServiceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.readNamespacedServiceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified Node
     */
    async readNodeRaw(requestParameters: CoreV1ApiReadNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * read the specified Node
     */
    async readNode(requestParameters: CoreV1ApiReadNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Node> {
        const response = await this.readNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified Node
     */
    async readNodeStatusRaw(requestParameters: CoreV1ApiReadNodeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readNodeStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * read status of the specified Node
     */
    async readNodeStatus(requestParameters: CoreV1ApiReadNodeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Node> {
        const response = await this.readNodeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read the specified PersistentVolume
     */
    async readPersistentVolumeRaw(requestParameters: CoreV1ApiReadPersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readPersistentVolume().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolume
     */
    async readPersistentVolume(requestParameters: CoreV1ApiReadPersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.readPersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readPersistentVolumeStatusRaw(requestParameters: CoreV1ApiReadPersistentVolumeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling readPersistentVolumeStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readPersistentVolumeStatus(requestParameters: CoreV1ApiReadPersistentVolumeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.readPersistentVolumeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Namespace
     */
    async replaceNamespaceRaw(requestParameters: CoreV1ApiReplaceNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespace().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace the specified Namespace
     */
    async replaceNamespace(requestParameters: CoreV1ApiReplaceNamespaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.replaceNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceNamespaceFinalizeRaw(requestParameters: CoreV1ApiReplaceNamespaceFinalizeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespaceFinalize().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespaceFinalize().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/finalize`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceNamespaceFinalize(requestParameters: CoreV1ApiReplaceNamespaceFinalizeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.replaceNamespaceFinalizeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceNamespaceStatusRaw(requestParameters: CoreV1ApiReplaceNamespaceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Namespace>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespaceStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespaceStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NamespaceToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceNamespaceStatus(requestParameters: CoreV1ApiReplaceNamespaceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Namespace> {
        const response = await this.replaceNamespaceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceNamespacedConfigMapRaw(requestParameters: CoreV1ApiReplaceNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ConfigMap>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedConfigMap().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedConfigMap().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedConfigMap().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ConfigMapToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ConfigMapFromJSON(jsonValue));
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceNamespacedConfigMap(requestParameters: CoreV1ApiReplaceNamespacedConfigMapRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ConfigMap> {
        const response = await this.replaceNamespacedConfigMapRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Endpoints
     */
    async replaceNamespacedEndpointsRaw(requestParameters: CoreV1ApiReplaceNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Endpoints>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedEndpoints().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedEndpoints().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedEndpoints().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1EndpointsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1EndpointsFromJSON(jsonValue));
    }

    /**
     * replace the specified Endpoints
     */
    async replaceNamespacedEndpoints(requestParameters: CoreV1ApiReplaceNamespacedEndpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Endpoints> {
        const response = await this.replaceNamespacedEndpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Event
     */
    async replaceNamespacedEventRaw(requestParameters: CoreV1ApiReplaceNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CoreV1Event>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedEvent().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedEvent().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedEvent().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CoreV1EventToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CoreV1EventFromJSON(jsonValue));
    }

    /**
     * replace the specified Event
     */
    async replaceNamespacedEvent(requestParameters: CoreV1ApiReplaceNamespacedEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CoreV1Event> {
        const response = await this.replaceNamespacedEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified LimitRange
     */
    async replaceNamespacedLimitRangeRaw(requestParameters: CoreV1ApiReplaceNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1LimitRange>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedLimitRange().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedLimitRange().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedLimitRange().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1LimitRangeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1LimitRangeFromJSON(jsonValue));
    }

    /**
     * replace the specified LimitRange
     */
    async replaceNamespacedLimitRange(requestParameters: CoreV1ApiReplaceNamespacedLimitRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1LimitRange> {
        const response = await this.replaceNamespacedLimitRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaimRaw(requestParameters: CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedPersistentVolumeClaim().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedPersistentVolumeClaim().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedPersistentVolumeClaim().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeClaimToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaim(requestParameters: CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.replaceNamespacedPersistentVolumeClaimRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaimStatusRaw(requestParameters: CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolumeClaim>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedPersistentVolumeClaimStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeClaimToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceNamespacedPersistentVolumeClaimStatus(requestParameters: CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolumeClaim> {
        const response = await this.replaceNamespacedPersistentVolumeClaimStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Pod
     */
    async replaceNamespacedPodRaw(requestParameters: CoreV1ApiReplaceNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedPod().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedPod().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedPod().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * replace the specified Pod
     */
    async replaceNamespacedPod(requestParameters: CoreV1ApiReplaceNamespacedPodRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.replaceNamespacedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     */
    async replaceNamespacedPodEphemeralcontainersRaw(requestParameters: CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedPodEphemeralcontainers().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedPodEphemeralcontainers().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedPodEphemeralcontainers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     */
    async replaceNamespacedPodEphemeralcontainers(requestParameters: CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.replaceNamespacedPodEphemeralcontainersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Pod
     */
    async replaceNamespacedPodStatusRaw(requestParameters: CoreV1ApiReplaceNamespacedPodStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Pod>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedPodStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedPodStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedPodStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Pod
     */
    async replaceNamespacedPodStatus(requestParameters: CoreV1ApiReplaceNamespacedPodStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Pod> {
        const response = await this.replaceNamespacedPodStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceNamespacedPodTemplateRaw(requestParameters: CoreV1ApiReplaceNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PodTemplate>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedPodTemplate().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedPodTemplate().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedPodTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PodTemplateToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PodTemplateFromJSON(jsonValue));
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceNamespacedPodTemplate(requestParameters: CoreV1ApiReplaceNamespacedPodTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PodTemplate> {
        const response = await this.replaceNamespacedPodTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerRaw(requestParameters: CoreV1ApiReplaceNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedReplicationController().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedReplicationController().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedReplicationController().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ReplicationControllerToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceNamespacedReplicationController(requestParameters: CoreV1ApiReplaceNamespacedReplicationControllerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationController> {
        const response = await this.replaceNamespacedReplicationControllerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerScaleRaw(requestParameters: CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Scale>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedReplicationControllerScale().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedReplicationControllerScale().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedReplicationControllerScale().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ScaleToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ScaleFromJSON(jsonValue));
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerScale(requestParameters: CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Scale> {
        const response = await this.replaceNamespacedReplicationControllerScaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerStatusRaw(requestParameters: CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ReplicationController>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedReplicationControllerStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedReplicationControllerStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedReplicationControllerStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ReplicationControllerToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceNamespacedReplicationControllerStatus(requestParameters: CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ReplicationController> {
        const response = await this.replaceNamespacedReplicationControllerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceNamespacedResourceQuotaRaw(requestParameters: CoreV1ApiReplaceNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedResourceQuota().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedResourceQuota().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedResourceQuota().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ResourceQuotaToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceNamespacedResourceQuota(requestParameters: CoreV1ApiReplaceNamespacedResourceQuotaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.replaceNamespacedResourceQuotaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceNamespacedResourceQuotaStatusRaw(requestParameters: CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ResourceQuota>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedResourceQuotaStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedResourceQuotaStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedResourceQuotaStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ResourceQuotaToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceNamespacedResourceQuotaStatus(requestParameters: CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ResourceQuota> {
        const response = await this.replaceNamespacedResourceQuotaStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Secret
     */
    async replaceNamespacedSecretRaw(requestParameters: CoreV1ApiReplaceNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Secret>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedSecret().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedSecret().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedSecret().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1SecretToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1SecretFromJSON(jsonValue));
    }

    /**
     * replace the specified Secret
     */
    async replaceNamespacedSecret(requestParameters: CoreV1ApiReplaceNamespacedSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Secret> {
        const response = await this.replaceNamespacedSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Service
     */
    async replaceNamespacedServiceRaw(requestParameters: CoreV1ApiReplaceNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedService().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedService().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedService().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * replace the specified Service
     */
    async replaceNamespacedService(requestParameters: CoreV1ApiReplaceNamespacedServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.replaceNamespacedServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceNamespacedServiceAccountRaw(requestParameters: CoreV1ApiReplaceNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1ServiceAccount>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedServiceAccount().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedServiceAccount().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedServiceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceAccountToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceNamespacedServiceAccount(requestParameters: CoreV1ApiReplaceNamespacedServiceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1ServiceAccount> {
        const response = await this.replaceNamespacedServiceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Service
     */
    async replaceNamespacedServiceStatusRaw(requestParameters: CoreV1ApiReplaceNamespacedServiceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Service>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNamespacedServiceStatus().'
            );
        }

        if (requestParameters['namespace'] == null) {
            throw new runtime.RequiredError(
                'namespace',
                'Required parameter "namespace" was null or undefined when calling replaceNamespacedServiceStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNamespacedServiceStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters['namespace']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1ServiceToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1ServiceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Service
     */
    async replaceNamespacedServiceStatus(requestParameters: CoreV1ApiReplaceNamespacedServiceStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Service> {
        const response = await this.replaceNamespacedServiceStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified Node
     */
    async replaceNodeRaw(requestParameters: CoreV1ApiReplaceNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNode().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NodeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * replace the specified Node
     */
    async replaceNode(requestParameters: CoreV1ApiReplaceNodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Node> {
        const response = await this.replaceNodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified Node
     */
    async replaceNodeStatusRaw(requestParameters: CoreV1ApiReplaceNodeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1Node>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replaceNodeStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replaceNodeStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1NodeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1NodeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Node
     */
    async replaceNodeStatus(requestParameters: CoreV1ApiReplaceNodeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1Node> {
        const response = await this.replaceNodeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolume
     */
    async replacePersistentVolumeRaw(requestParameters: CoreV1ApiReplacePersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replacePersistentVolume().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replacePersistentVolume().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolume
     */
    async replacePersistentVolume(requestParameters: CoreV1ApiReplacePersistentVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.replacePersistentVolumeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replacePersistentVolumeStatusRaw(requestParameters: CoreV1ApiReplacePersistentVolumeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<V1PersistentVolume>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling replacePersistentVolumeStatus().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling replacePersistentVolumeStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pretty'] != null) {
            queryParameters['pretty'] = requestParameters['pretty'];
        }

        if (requestParameters['dryRun'] != null) {
            queryParameters['dryRun'] = requestParameters['dryRun'];
        }

        if (requestParameters['fieldManager'] != null) {
            queryParameters['fieldManager'] = requestParameters['fieldManager'];
        }

        if (requestParameters['fieldValidation'] != null) {
            queryParameters['fieldValidation'] = requestParameters['fieldValidation'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = await this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V1PersistentVolumeToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replacePersistentVolumeStatus(requestParameters: CoreV1ApiReplacePersistentVolumeStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<V1PersistentVolume> {
        const response = await this.replacePersistentVolumeStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
